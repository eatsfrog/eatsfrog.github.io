<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ian Roman Villanueva">

<title>From CSV Mess to Data Success</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="2024-10-04-from-csv-mess-to-data-success_files/libs/clipboard/clipboard.min.js"></script>
<script src="2024-10-04-from-csv-mess-to-data-success_files/libs/quarto-html/quarto.js"></script>
<script src="2024-10-04-from-csv-mess-to-data-success_files/libs/quarto-html/popper.min.js"></script>
<script src="2024-10-04-from-csv-mess-to-data-success_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2024-10-04-from-csv-mess-to-data-success_files/libs/quarto-html/anchor.min.js"></script>
<link href="2024-10-04-from-csv-mess-to-data-success_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2024-10-04-from-csv-mess-to-data-success_files/libs/quarto-html/quarto-syntax-highlighting-2486e1f0a3ee9ee1fc393803a1361cdb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2024-10-04-from-csv-mess-to-data-success_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2024-10-04-from-csv-mess-to-data-success_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2024-10-04-from-csv-mess-to-data-success_files/libs/bootstrap/bootstrap-5bdc1ec511977dd36301403cf8f4f68d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">From CSV Mess to Data Success</h1>
<p class="subtitle lead">Harness the power of pandas to turn your scattered datasets into a streamlined and comprehensive analysis!</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ian Roman Villanueva </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>Welcome to Data Ponderings! In this guide, we’ll explore how to use pandas, a powerful Python library, to efficiently merge CSV files into a single, cohesive dataset. Whether you’re a seasoned data scientist or just starting out, this guide will help you navigate the waters of file merging with ease. Let’s dive in!</p>
<section id="to-merge-or-not-to-merge" class="level2">
<h2 class="anchored" data-anchor-id="to-merge-or-not-to-merge">To Merge Or Not To Merge?</h2>
<p>Picture this: you’re a curious frog researcher with two separate sources of information. In one source, you have data about various frog species - their sizes, colors, and croaking patterns. In the other, you have detailed records of the ponds they inhabit - water quality, vegetation, and insect populations.</p>
<p>Separately, these data files tell different stories. But merge them together and suddenly a whole new stream of insights flows! You can now answer complex questions like “Do frogs with louder croaks prefer cleaner water?” or “Is there a correlation between pond vegetation and frog size?”</p>
<p>This is the power of merging CSV files! It’s not just about combining data; it’s about creating connections, revealing patterns, and unlocking insights that were previously hidden beneath the surface.</p>
</section>
<section id="pandas-your-new-bamboo-friend" class="level2">
<h2 class="anchored" data-anchor-id="pandas-your-new-bamboo-friend">Pandas: Your New Bamboo Friend</h2>
<p>Now that you’re convinced in the power of merging, you might be asking yourself “Why use pandas?” This Python library stands out as a powerful and versatile option for several reasons:</p>
<ul>
<li><p>Ease of Use: Load, merge, and transform complex datasets with just a few lines of code.</p></li>
<li><p>Performance: Efficiently handles both small projects and big data tasks.</p></li>
<li><p>Flexibility: Easily manage missing data and complex operations, with the freedom to undo changes.</p></li>
<li><p>Python Integration: Works seamlessly with matplotlib, scikit-learn, and NumPy for end-to-end data science.</p></li>
<li><p>Format Support: Handles CSV, Excel, SQL, JSON, and more - though we’ll focus on CSV today.</p></li>
</ul>
<p>By choosing pandas for your data merging tasks, you’re not just solving an immediate problem – you’re equipping yourself with a powerful tool that can handle a wide range of data manipulation challenges.</p>
<p>With that in mind, let’s practice some CSV merging!</p>
</section>
<section id="prerequisites" class="level2">
<h2 class="anchored" data-anchor-id="prerequisites">Prerequisites</h2>
<p><strong>Before we dive in, make sure you’ve got:</strong> - Python 3.9 or newer - The pandas library - Our example CSV files: <a href=".\assets/files/frog_baseline.csv"><code>frog_baseline.csv</code></a>, <a href=".\assets/files/frog_baseline_update.csv"><code>frog_baseline_update.csv</code></a>, and <a href=".\assets/files/frog_new_arrivals.csv"><code>frog_new_arrivals.csv</code></a></p>
<p>New to Python or pandas? No worries! Check out these beginner guides on <a href="https://www.geeksforgeeks.org/python-basics/">Python basics</a> and <a href="https://www.geeksforgeeks.org/introduction-to-pandas-in-python/">pandas fundamentals</a> before diving in.</p>
</section>
<section id="a-real-world-scenario-frog-sanctuary" class="level2">
<h2 class="anchored" data-anchor-id="a-real-world-scenario-frog-sanctuary">A Real-World Scenario: Frog Sanctuary</h2>
<p>Imagine you’re a data analyst at a frog sanctuary. You’ve got three CSV files to work with: 1. <code>frog_baseline.csv</code> - containing basic information about our amphibian friends 2. <code>frog_baseline_update.csv</code> - with updated information on health status, call frequency, and max hop distance 3. <code>frog_new_arrivals.csv</code> - detailing new frogs that have arrived at our sanctuary</p>
<p>Your mission is to combine these datasets to get a full picture of our frog population. This way, we can track changes in their health and behavior, spot trends, and make data-driven decisions to keep our frogs happy and healthy.</p>
<p>Let’s make some data magic!</p>
</section>
<section id="hopping-through-the-process-a-step-by-step-guide" class="level2">
<h2 class="anchored" data-anchor-id="hopping-through-the-process-a-step-by-step-guide">Hopping Through the Process: A Step-by-Step Guide</h2>
<section id="understanding-our-data" class="level3">
<h3 class="anchored" data-anchor-id="understanding-our-data">1. Understanding our data</h3>
<p>First, let’s import <code>frog_baseline</code> to take a quick peek at our baseline data.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">### Load datasets</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>baseline_df <span class="op">=</span> pd.read_csv(<span class="st">'frog_baseline.csv'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>baseline_update_df <span class="op">=</span> pd.read_csv(<span class="st">'frog_baseline_update.csv'</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>new_arrivals_df <span class="op">=</span> pd.read_csv(<span class="st">'frog_new_arrivals.csv'</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">### Preview Data</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Baseline data shape:"</span>, baseline_df.shape)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(baseline_df.head(<span class="dv">3</span>), end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Baseline update data shape:"</span>, baseline_update_df.shape)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(baseline_update_df.head(<span class="dv">3</span>), end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"New arrivals data shape:"</span>, new_arrivals_df.shape)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(new_arrivals_df.head(<span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<pre><code>Baseline data shape: (79, 6)
   frog_id       species     sex  weight  age  size
0     3001     Dart Frog    Male   340.8    5  3.52
1     3002     Tree Frog  Female   432.4    7  5.00
2     3003  Leopard Frog  Female   434.0   10  5.49

Baseline update data shape: (79, 6)
   frog_id habitat   health  max_hop  thermal_limit  call_freq
0     3001    Pond  Healthy     1.66          31.15     455.50
1     3002    Pond  Healthy     2.55          27.86     369.87
2     3003   Swamp  Healthy     2.86          27.59     413.24

New arrivals data shape: (23, 12)
   frog_id       species   sex habitat   health  weight  size  age  max_hop  \
0     3078  Leopard Frog  Male  Forest  Healthy   811.1  6.44    5     2.89   
1     3079  Leopard Frog  Male    Pond     Sick   584.5  7.90    6     2.53   
2     3080     Dart Frog  Male  Forest  Healthy   413.4  5.80    7     2.31   

   thermal_limit  call_freq arrival_date  
0          27.45     479.92   2023-01-01  
1          29.99     396.86   2023-01-02  
2          28.08     368.61   2023-01-03</code></pre>
<p>We have three datasets:</p>
<ul>
<li><p>baseline_df: Basic information on 79 frogs (6 features).</p></li>
<li><p>baseline_update_df: Updated details on the same 79 frogs (frog_id + 5 additional features).</p></li>
<li><p>new_arrivals_df: Comprehensive data on 23 new frogs (12 features, including arrival date).</p></li>
</ul>
</section>
<section id="merging-our-data" class="level3">
<h3 class="anchored" data-anchor-id="merging-our-data">2. Merging our data</h3>
<p>Let’s tackle this merge step by step. First, we’ll combine <code>baseline_df</code> with <code>baseline_update_df</code> to create a complete record of our existing frogs. Then, we’ll add the newcomers by merging in <code>new_arrivals_df</code>. This approach ensures we maintain a clean and organized dataset throughout the process.</p>
<section id="joining-baseline_df-and-baseline_update_df" class="level4">
<h4 class="anchored" data-anchor-id="joining-baseline_df-and-baseline_update_df">2.1. Joining <code>baseline_df</code> and <code>baseline_update_df</code></h4>
<p>First, we’ll merge <code>baseline_df</code> and <code>baseline_update_df</code> together. We can do this by using a join, which is a specific type of merge. You can think of a join as putting two datasets side by side and sticking them together.</p>
<p>We’ll use the pd.merge function to join DataFrames based on a common column. Here’s the basic syntax:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pd.merge(left, right, how<span class="op">=</span><span class="st">'inner'</span>, on<span class="op">=</span><span class="va">None</span>, left_on<span class="op">=</span><span class="va">None</span>, right_on<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>left</code> and <code>right</code> are the DataFrames to merge. <code>left</code> should always be your “original” dataset or the dataset of most importance.</li>
<li><code>how</code> specifies the type of merge: ‘inner’, ‘outer’, ‘left’, or ‘right’. For more information, see <a href="https://www.geeksforgeeks.org/different-types-of-joins-in-pandas/">this post</a>.</li>
<li><code>on</code> specifies the column(s) to merge on. Both datasets should contain these columns.
<ul>
<li><code>left_on</code> and <code>right_on</code> are used when the merge columns have different names in the left and right DataFrames</li>
</ul></li>
</ul>
<p>In this case, our merge would look like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> pd.merge(baseline_df, baseline_update_df, on<span class="op">=</span><span class="st">'frog_id'</span>, how<span class="op">=</span><span class="st">'outer'</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(merged_df.shape, end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(merged_df.head())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<pre><code>(81, 11)

   frog_id       species     sex  weight   age  size habitat   health  \
0        0           NaN     NaN     NaN   NaN   NaN     NaN      NaN   
1     3001     Dart Frog    Male   340.8   5.0  3.52    Pond  Healthy   
2     3002     Tree Frog  Female   432.4   7.0  5.00    Pond  Healthy   
3     3003  Leopard Frog  Female   434.0  10.0  5.49   Swamp  Healthy   
4     3004     Tree Frog  Female   124.9   7.0  2.19    Pond  Healthy   

   max_hop  thermal_limit  call_freq  
0     0.00           0.00       0.00  
1     1.66          31.15     455.50  
2     2.55          27.86     369.87  
3     2.86          27.59     413.24  
4     1.48          31.67     779.69</code></pre>
<p>As we can see, we’ve successfully merged our datasets and we now have more detailed information for each frog. However, we can see that we have a row with NaN values and the datasets add up to 81 frogs not 79. Usually, we’d investigate this and fix it before proceeding any further, but for now, we’ll continue.</p>
</section>
<section id="concatenating-merged_df-and-new_arrivals_df" class="level4">
<h4 class="anchored" data-anchor-id="concatenating-merged_df-and-new_arrivals_df">2.2. Concatenating <code>merged_df</code> and <code>new_arrivals_df</code></h4>
<p>The next step is to concatenate <code>merged_df</code> and <code>new_arrivals_df</code>. Concatenating is like stacking a dataset on each other, like LEGOs. The only requirement is that we have have the same columns or rows on each dataset.</p>
<p>We’ll use the <code>pd.concat</code> function for this task. The basic syntax is:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>pd.concat([df1, df2, ...], axis<span class="op">=</span><span class="dv">0</span>, ignore_index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>[df1, df2, ...]</code> is a list of DataFrames to concatenate</li>
<li><code>axis=0</code> concatenates vertically (stacking), while <code>axis=1</code> concatenates horizontally</li>
<li><code>ignore_index=True</code> resets the index of the result</li>
</ul>
<p>For our datasets, this is what this would look like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> pd.concat([merged_df, new_arrivals_df], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df.shape,end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df.head())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<pre><code>(104, 12)

   frog_id       species     sex  weight   age  size habitat   health  \
0        0           NaN     NaN     NaN   NaN   NaN     NaN      NaN   
1     3001     Dart Frog    Male   340.8   5.0  3.52    Pond  Healthy   
2     3002     Tree Frog  Female   432.4   7.0  5.00    Pond  Healthy   
3     3003  Leopard Frog  Female   434.0  10.0  5.49   Swamp  Healthy   
4     3004     Tree Frog  Female   124.9   7.0  2.19    Pond  Healthy   

   max_hop  thermal_limit  call_freq arrival_date  
0     0.00           0.00       0.00          NaN  
1     1.66          31.15     455.50          NaN  
2     2.55          27.86     369.87          NaN  
3     2.86          27.59     413.24          NaN  
4     1.48          31.67     779.69          NaN</code></pre>
<p>Voilà! We’ve successfully merged all our datasets together. Now, can address those pesky errors that have been accumulating in our dataset.</p>
</section>
</section>
<section id="identifying-and-fixing-errors" class="level3">
<h3 class="anchored" data-anchor-id="identifying-and-fixing-errors">3. Identifying and Fixing Errors</h3>
<p>Now that we’ve merged our datasets, let’s dive into some data cleaning to ensure our frog information is as pristine as a crystal-clear pond.</p>
<section id="duplicate-entries" class="level4">
<h4 class="anchored" data-anchor-id="duplicate-entries">Duplicate Entries</h4>
<p>First, let’s check for any duplicate entries that might have snuck in during our merging process. We’ll use pandas’ built-in functions to identify and remove these pesky doubles.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Print all duplicated rows in the DataFrame</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df[final_df.duplicated(keep<span class="op">=</span><span class="va">False</span>)])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop duplicate rows, keeping only the first occurrence</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>final_df.drop_duplicates(keep<span class="op">=</span><span class="st">'first'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the shape of the DataFrame after dropping duplicates</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<pre><code>    frog_id   species     sex  weight  age  size habitat   health  max_hop  \
77     3077  Bullfrog  Female   897.9  5.0  7.34   Swamp  Healthy     3.14   
78     3077  Bullfrog  Female   897.9  5.0  7.34   Swamp  Healthy     3.14   

    thermal_limit  call_freq arrival_date  
77          28.31      356.9          NaN  
78          28.31      356.9          NaN  

(103, 12)</code></pre>
<p>Looks like we had a Bullfrog trying to make a double splash in our dataset! We’ve successfully removed the duplicate, leaving us with 103 unique frog entries.</p>
</section>
<section id="missing-values" class="level4">
<h4 class="anchored" data-anchor-id="missing-values">Missing Values</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>missing_values <span class="op">=</span> final_df.isnull().<span class="bu">sum</span>()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Missing values per column:"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(missing_values)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Fill missing values with 'Unknown'</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>final_df.fillna(<span class="st">'Unknown'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mismatched-columns" class="level4">
<h4 class="anchored" data-anchor-id="mismatched-columns">Mismatched Columns</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Columns in the final DataFrame:"</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df.columns)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Ensure all expected columns are present</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>expected_columns <span class="op">=</span> [<span class="st">'Frog_ID'</span>, <span class="st">'Sex'</span>, <span class="st">'Age'</span>, <span class="st">'Weight'</span>, <span class="st">'Location'</span>, <span class="st">'Health_Status'</span>, <span class="st">'Diet_Type'</span>, <span class="st">'Last_Checkup'</span>, <span class="st">'Notes'</span>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> expected_columns:</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> final_df.columns:</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        final_df[col] <span class="op">=</span> <span class="st">'Unknown'</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Reorder columns</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> final_df[expected_columns]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="data-type-inconsistencies" class="level4">
<h4 class="anchored" data-anchor-id="data-type-inconsistencies">Data Type Inconsistencies</h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df.dtypes)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert 'Age' to integer, replacing any non-numeric values with NaN</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">'Age'</span>] <span class="op">=</span> pd.to_numeric(final_df[<span class="st">'Age'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>).fillna(<span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert 'Weight' to float</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">'Weight'</span>] <span class="op">=</span> pd.to_numeric(final_df[<span class="st">'Weight'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert 'Last_Checkup' to datetime</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">'Last_Checkup'</span>] <span class="op">=</span> pd.to_datetime(final_df[<span class="st">'Last_Checkup'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="analyzing-our-cleaned-data" class="level3">
<h3 class="anchored" data-anchor-id="analyzing-our-cleaned-data">4. Analyzing our cleaned data</h3>
<p>Let’s check our final dataset:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df.info())</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_df.describe())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="saving-our-new-file" class="level3">
<h3 class="anchored" data-anchor-id="saving-our-new-file">5. Saving our new file</h3>
<p>Finally, let’s save our newly merged and cleaned data:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>final_df.to_csv(<span class="st">'comprehensive_frog_data.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This creates a new CSV in your current directory with all our frog data combined and cleaned.</p>
</section>
</section>
<section id="a-note-on-proactive-error-handling" class="level2">
<h2 class="anchored" data-anchor-id="a-note-on-proactive-error-handling">A Note on Proactive Error Handling</h2>
<p>If we had wanted to fix these errors from the beginning, we could have used similar techniques before merging or concatenating the DataFrames. For example:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clean_dataframe(df):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    df.drop_duplicates(subset<span class="op">=</span>[<span class="st">'frog_id'</span>], keep<span class="op">=</span><span class="st">'first'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    df.fillna(<span class="st">'Unknown'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add other cleaning steps as needed</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>clean_baseline_df <span class="op">=</span> clean_dataframe(baseline_df)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>clean_update_df <span class="op">=</span> clean_dataframe(update_df)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>clean_new_arrivals_df <span class="op">=</span> clean_dataframe(new_arrivals_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However, for the purposes of this guide, we chose to demonstrate error handling after merging to highlight common issues that can arise during the process.</p>
</section>
<section id="conclusion-the-circle-of-data-life" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-the-circle-of-data-life">Conclusion: The Circle of Data Life</h2>
<p>And there you have it, folks! We’ve successfully merged our frog datasets, creating a richer, more insightful pond of information. Remember, just as in nature, in data science, everything is connected. By merging our datasets we’ve created a more complete and accurate picture of our frog sanctuary ecosystem.</p>
<p>Now it’s your turn to take the plunge! What datasets will you merge? What insights will you uncover in the depths of your data pond? Share your discoveries in the comments below, or hop over to our forum to discuss further!</p>
<p><strong>Until next time, keep your data clean and your algorithms green!</strong></p>
</section>
<section id="further-reading-resources" class="level2">
<h2 class="anchored" data-anchor-id="further-reading-resources">Further Reading / Resources</h2>
<ul>
<li><p>GeeksforGeeks: <a href="https://www.geeksforgeeks.org/different-types-of-joins-in-pandas/">“Different Types of Joins in Pandas”</a></p></li>
<li><p>GeeksforGeeks: <a href="https://www.geeksforgeeks.org/how-to-merge-two-csv-files-by-specific-column-using-pandas-in-python/">“How to merge two csv files by specific column using Pandas in Python?”</a></p></li>
<li><p>Geeksforgeeks: <a href="https://www.geeksforgeeks.org/python-basics/">“Learn Python Basics”</a></p></li>
<li><p>Geeksforgeeks: <a href="https://www.geeksforgeeks.org/introduction-to-pandas-in-python/">“Pandas Introduction”</a></p></li>
<li><p>Pandas documentation: <a href="https://pandas.pydata.org/docs/reference/api/pandas.merge.html"><code>pd.merge()</code></a> and <a href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html"><code>pd.concat()</code></a></p></li>
<li><p>Statology: <a href="https://www.statology.org/pandas-merge-csv-files/">“How to Merge Multiple CSV Files in Pandas”</a></p></li>
<li><p>Towards Data Science: <a href="https://towardsdatascience.com/20-examples-to-master-merging-dataframes-in-python-pandas-22ffcd6059d1">“20 Examples to Master Merging DataFrames in Python Pandas”</a></p></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>